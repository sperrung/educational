
обобщающие функции: 
COUNT — считает количество значений в колонке.
SUM — вычисляет сумму значений.
AVG — вычисляет среднее значение.
MAX — вычисляет максимальное значение.
MIN — вычисляет минимальное значение.

при подсчёте количества записей иногда вместо наименования колонки в качестве атрибута функции COUNT используют звёздочку «*»:

SELECT COUNT(*)
FROM table
Однако важно учитывать один нюанс: запрос со звёздочкой возвращает количество вообще всех записей в таблице, 
а запрос с указанием столбца — количество тех записей, где в заданном столбце значения не являются NULL.
Таким образом, если в некоторой колонке column есть пропуски, выражения COUNT(*) и COUNT(column) вернут разные значения.

агрегирующие функции можно применять в сочетании с ключевым словом DISTINCT. В таком случае расчёты будут производиться только по уникальным значениям.

Если в случае с MIN и MAX это не имеет особого смысла, то при расчёте AVG, SUM и COUNT иногда это бывает полезно:
SELECT SUM(DISTINCT column) AS sum_distinct
FROM table

При этом довольно часто DISTINCT используется именно в сочетании с COUNT — для подсчёта числа уникальных пользователей, 
уникальных заказов и т.д.

SELECT COUNT(DISTINCT column) AS count_distinct
FROM table

А что если для расчётов нам нужны не все данные в столбце, а только какая-то часть? 
Тогда в запрос с агрегирующими функциями можно включить оператор WHERE, указав условие для отбора записей:

SELECT COUNT(column_1) AS count
FROM table
WHERE column_2 > 100

В таком случае сначала будет выполнена фильтрация таблицы и только потом будет произведена агрегация по оставшимся записям.
На всякий случай напомним порядок выполнения в запросе известных нам ключевых операторов:

FROM       -- выбор источника данных
WHERE      -- фильтрация данных
SELECT     -- перечисление полей результирующей таблицы и проведение расчётов
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей

Аргументом агрегирующей функции может быть и более сложная расчётная колонка — например, полученная в результате работы конструкции CASE.
В таком случае сама конструкция CASE помещается внутрь скобок агрегирующей функции:

AVG(
    CASE  
    WHEN logical_expression_1 THEN expression_1
    WHEN logical_expression_2 THEN expression_2
    ELSE expression_else
    END
)

**Функция array_length** вычисляет количество элементов в массиве (длину массива) и записывается следующим образом:
SELECT array_length(ARRAY[1,2,3], 1)

Результат:
3

Синтаксис может показаться вам немного сложным, но это только на первый взгляд! Давайте разбираться. 
ARRAY[1,2,3] — это некоторый список из трёх значений: 1, 2 и 3.
Единица в качестве второго аргумента — это размерность массива, по которой считается его длина. 
Так как список у нас одноразмерный (просто значения, записанные в одну строчку), 
то выбор у нас невелик — можем указать только первую размерность.

Если бы у нас была таблица N x N, в которой были бы и строки, и столбцы, 
то размерности было бы две: первая соответствовала бы количеству строк, а вторая — числу столбцов. 
В таком случае мы могли бы указать либо первую, либо вторую размерность.
Давайте представим, что у нас есть простая таблица следующего вида:

 _______
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
 ‾‾‾‾‾‾‾

В этой таблице 3 строки и 2 столбца, поэтому её можно описать в виде следующего списка из трёх вложенных в него списков:

ARRAY[[1,2], [3,4], [5,6]]

В примере выше количество списков внутри основного списка — это количество строк в таблице,
а количество элементов внутри каждого внутреннего списка — это количество столбцов.

Обратите внимание на результат вычислений функции array_length для первой и второй размерностей:
SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)
Результат:
3
SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)
Результат:
2

ГРУППИРОВКА --

1) группировку можно делать сразу по нескольким колонкам:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1, column_2


В таком случае количество групп в результирующей таблице будет равно числу уникальных комбинаций значений в нескольких столбцах, указанных в GROUP BY. При этом для каждой такой группы будет проведена агрегация значений по колонке, указанной в качества аргумента агрегирующей функции.

2) к группам, образовавшимся в результате GROUP BY, можно применять сразу несколько агрегирующих функций (в том числе к разным колонкам):

SELECT column_1, SUM(column_2) AS sum, AVG(column_3) AS avg
FROM table
GROUP BY column_1


При этом агрегирующую функцию можно применить к той же самой колонке, по которой осуществляется группировка:

SELECT column_1, COUNT(column_1) AS count
FROM table
GROUP BY column_1


Не всегда такая операция имеет смысл, но она допустима. Например, с помощью функции COUNT можно посчитать количество записей, попавших в каждую группу.

3) В-третьих, после группировки к результатам агрегирующих функций можно применять другие функции. Также над ними можно сразу проводить арифметические операции:

SELECT column_1, ROUND(SUM(column_2), 2) AS rounded_sum
FROM table
GROUP BY column_1


SELECT column_1, SUM(column_2)::DECIMAL / SUM(column_3) * 100 AS share
FROM table
GROUP BY column_1


4) В-четвёртых, агрегацию не обязательно проводить по уже имеющимся колонкам — можно сначала применить некоторую функцию в колонке из исходной таблицы, а затем сразу провести агрегацию по новой колонке:

SELECT column_1, SUM(some_function(column_2)) AS sum_over_function
FROM table
GROUP BY column_1


5) В-пятых, группировку можно делать сразу по новым полям, посчитанным в SELECT. При этом допускается использование в GROUP BY алиаса колонки, указанного в SELECT.

Например, если нам необходимо сгруппировать данные по дням, выделив дату из какой-то колонки, и посчитать сумму некоторых значений в каждый из дней, то можно использовать следующие запросы, которые дадут одинаковый результат:

SELECT DATE(column_1) AS date, SUM(column_2) AS sum
FROM table
GROUP BY DATE(column_1)


SELECT DATE(column_1) AS date, SUM(column_2) AS sum
FROM table
GROUP BY date


Важно: несмотря на то, что в соответствии с порядком выполнения операторов блок SELECT выполняется после блока GROUP BY, в данном случае PostgreSQL позволяет нам немного отойти от правил и упростить процесс написания запроса. Однако такой «синтаксический сахар» есть не в каждой СУБД, поэтому при работе с другими инструментами будьте аккуратны — в общем случае рекомендуется дублировать расчётное поле в блоке GROUP BY и не использовать в нём алиасы колонок из SELECT.

6) делать агрегацию после группировки не обязательно. Если не указать агрегирующую функцию, то запрос вернёт уникальные значения в столбце (или уникальные комбинации значений в столбцах), т.е. тот же результат, что и оператор DISTINCT. 

SELECT user_id
FROM user_actions
GROUP BY user_id


SELECT DISTINCT user_id
FROM user_actions


Кстати, вопрос о том, какими способами можно отобрать уникальные значения в столбце, часто встречается на собеседованиях.

7) при использовании группировки колонки, указанные в SELECT, должны находиться и в GROUP BY, если они не используются в агрегирующих функциях.

Это обязательное условие, и если оно не будет выполнено, то база данных вернёт ошибку.

Следующий запрос работать не будет, так как в GROUP BY указаны не все неагрегированные колонки из блока SELECT: 

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1


То есть в запросе выше мы сгруппировали данные по колонке column_1, но при этом попросили базу данных вывести группировку по колонкам column_1 и column_2 с расчётом суммы некоторых значений в колонке column_3. Так делать нельзя.

В данном случае правильным был бы следующий запрос:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1, column_2


Обратите внимание, что в обратную сторону указанное выше правило не работает: если мы что-то указали в GROUP BY, то это совсем не обязательно указывать в SELECT. Иными словами, можно не выводить наименования колонок, по которым осуществляется группировка.

Например, в этом запросе в блоке SELECT нет колонки, указанной в GROUP BY. Тем не менее такой запрос всё равно сработает:

SELECT SUM(column_2) AS sum
FROM table
GROUP BY column_1


Дело в том, что сама группировка всегда происходит до выполнения блока SELECT, где мы по сути указываем, что включить в результат. То есть даже если мы не укажем колонку в SELECT, но укажем её в GROUP BY, группы всё равно будут сформированы, но их наименования просто не будут включены в результирующую таблицу.

— И наконец, группировка всегда выполняется после фильтрации, т.е. сначала выполняются инструкции в WHERE и только потом данные группируются с помощью GROUP BY:

SELECT column_1, SUM(column_2) AS sum
FROM table
WHERE column_3 > 0
GROUP BY column_1


Таким образом, порядок записи ключевых слов выглядит так:

SELECT
FROM
WHERE
GROUP BY
ORDER BY
LIMIT
В то же время порядок выполнения операторов в запросе следующий:

Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
Далее WHERE — отфильтровываются строки, соответствующие условию.
Потом GROUP BY — строки объединяются в группы и производится агрегация.
Затем SELECT — отбираются указанные столбцы.
Потом ORDER BY — производится сортировка результирующей таблицы.
И в самом конце LIMIT — ограничивается количество выводимых записей.
И ещё: вместо названий колонок в блоке GROUP BY можно использовать порядковые номера колонок, указанных в SELECT. Например, следующие запросы эквивалентны:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1, column_2


SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY 1, 2


При этом номера колонок из SELECT можно также использовать при сортировке в операторе ORDER BY:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY 1, 2
ORDER BY 3


сгруппируем наши данные не по имеющейся в таблице колонке, а по расчётной.

Чтобы понять, как это работает, просто представьте, что сначала вы создаёте какую-то новую колонку на основе уже имеющейся, применяя к ней какую-то функцию, а потом сразу в этом же запросе производите группировку по новой колонке.

На первом шаге мы уже рассматривали пример с DATE — давайте рассмотрим ещё один:

SELECT UPPER(column_1) AS upper_column, SUM(column_2) AS sum
FROM table
GROUP BY UPPER(column_1)


Здесь мы сначала рассчитали колонку upper_column, применив функцию UPPER к колонке column_1, а затем сразу же сгруппировались по ней, посчитав сумму всех значений в колонке column_2 в каждой группе.

Напомним, что такой вариант запроса тоже сработает:

SELECT UPPER(column_1) AS upper_column, SUM(column_2) AS sum
FROM table
GROUP BY upper_column


А теперь, используя все эти знания, давайте посчитаем, сколько заказов было сделано в каждом месяце. Разумеется, для этого нам потребуется как-то получить месяц из каждой даты. Это можно было бы сделать с помощью функции DATE_PART, но в этот раз для работы с датами мы попробуем новую функцию DATE_TRUNC.