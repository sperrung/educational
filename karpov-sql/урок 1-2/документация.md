
обобщающие функции: 
COUNT — считает количество значений в колонке.
SUM — вычисляет сумму значений.
AVG — вычисляет среднее значение.
MAX — вычисляет максимальное значение.
MIN — вычисляет минимальное значение.

при подсчёте количества записей иногда вместо наименования колонки в качестве атрибута функции COUNT используют звёздочку «*»:

SELECT COUNT(*)
FROM table
Однако важно учитывать один нюанс: запрос со звёздочкой возвращает количество вообще всех записей в таблице, 
а запрос с указанием столбца — количество тех записей, где в заданном столбце значения не являются NULL.
Таким образом, если в некоторой колонке column есть пропуски, выражения COUNT(*) и COUNT(column) вернут разные значения.

агрегирующие функции можно применять в сочетании с ключевым словом DISTINCT. В таком случае расчёты будут производиться только по уникальным значениям.

Если в случае с MIN и MAX это не имеет особого смысла, то при расчёте AVG, SUM и COUNT иногда это бывает полезно:
SELECT SUM(DISTINCT column) AS sum_distinct
FROM table

При этом довольно часто DISTINCT используется именно в сочетании с COUNT — для подсчёта числа уникальных пользователей, 
уникальных заказов и т.д.

SELECT COUNT(DISTINCT column) AS count_distinct
FROM table

А что если для расчётов нам нужны не все данные в столбце, а только какая-то часть? 
Тогда в запрос с агрегирующими функциями можно включить оператор WHERE, указав условие для отбора записей:

SELECT COUNT(column_1) AS count
FROM table
WHERE column_2 > 100

В таком случае сначала будет выполнена фильтрация таблицы и только потом будет произведена агрегация по оставшимся записям.
На всякий случай напомним порядок выполнения в запросе известных нам ключевых операторов:

FROM       -- выбор источника данных
WHERE      -- фильтрация данных
SELECT     -- перечисление полей результирующей таблицы и проведение расчётов
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей

Аргументом агрегирующей функции может быть и более сложная расчётная колонка — например, полученная в результате работы конструкции CASE.
В таком случае сама конструкция CASE помещается внутрь скобок агрегирующей функции:

AVG(
    CASE  
    WHEN logical_expression_1 THEN expression_1
    WHEN logical_expression_2 THEN expression_2
    ELSE expression_else
    END
)

**Функция array_length** вычисляет количество элементов в массиве (длину массива) и записывается следующим образом:
SELECT array_length(ARRAY[1,2,3], 1)

Результат:
3

Синтаксис может показаться вам немного сложным, но это только на первый взгляд! Давайте разбираться. 
ARRAY[1,2,3] — это некоторый список из трёх значений: 1, 2 и 3.
Единица в качестве второго аргумента — это размерность массива, по которой считается его длина. 
Так как список у нас одноразмерный (просто значения, записанные в одну строчку), 
то выбор у нас невелик — можем указать только первую размерность.

Если бы у нас была таблица N x N, в которой были бы и строки, и столбцы, 
то размерности было бы две: первая соответствовала бы количеству строк, а вторая — числу столбцов. 
В таком случае мы могли бы указать либо первую, либо вторую размерность.
Давайте представим, что у нас есть простая таблица следующего вида:

 _______
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
 ‾‾‾‾‾‾‾

В этой таблице 3 строки и 2 столбца, поэтому её можно описать в виде следующего списка из трёх вложенных в него списков:

ARRAY[[1,2], [3,4], [5,6]]

В примере выше количество списков внутри основного списка — это количество строк в таблице,
а количество элементов внутри каждого внутреннего списка — это количество столбцов.

Обратите внимание на результат вычислений функции array_length для первой и второй размерностей:
SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)
Результат:
3
SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)
Результат:
2

